/**
 * AUTO-GENERATED - DO NOT EDIT
 * Generated by Claude from backend Go code
 * Source: orris backend node module
 * Last updated: 2026-01-02
 *
 * Note: Node IDs are now Stripe-style prefixed IDs (e.g., "node_xK9mP2vL3nQ")
 *
 * Recent changes:
 * - 2026-01-02: Added subscribeNodeEvents for SSE real-time node event subscription
 * - 2025-12-31: Added getNodeVersion and triggerNodeUpdate for node version management
 * - 2025-12-29: listNodes now supports sortBy and sortOrder params for admin node sorting
 * - 2025-12-28: No API changes - NodeSystemStatus type updated with procfs metrics
 * - 2025-12-22: listNodes now supports includeUserNodes param for admin node filtering
 * - 2025-12-20: Added user node management functions (createUserNode, listUserNodes, etc.)
 */

import { apiClient } from '@/shared/lib/axios';
import type { APIResponse, ListResponse } from '@/shared/types/api.types';
import type {
  Node,
  CreateNodeRequest,
  UpdateNodeRequest,
  UpdateNodeStatusRequest,
  ListNodesParams,
  GenerateNodeTokenResponse,
  GenerateNodeInstallScriptResponse,
  GetNodeInstallScriptParams,
  UserNode,
  CreateUserNodeRequest,
  CreateUserNodeResponse,
  UpdateUserNodeRequest,
  ListUserNodesParams,
  RegenerateUserNodeTokenResponse,
  UserNodeUsage,
  UserNodeInstallScriptResponse,
  GetUserNodeInstallScriptParams,
  NodeVersionInfo,
  TriggerNodeUpdateResponse,
  BatchUpdateRequest,
  BatchUpdateResponse,
  NodeEvent,
  NodeEventsParams,
} from './types';

// ============================================================================
// Node Management APIs (Admin)
// ============================================================================

/**
 * Create a new node
 * POST /nodes
 * @requires Admin role
 */
export async function createNode(data: CreateNodeRequest): Promise<Node> {
  const response = await apiClient.post<APIResponse<Node>>('/nodes', data);
  return response.data.data;
}

/**
 * Get node by ID
 * GET /nodes/:id
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 */
export async function getNode(id: string): Promise<Node> {
  const response = await apiClient.get<APIResponse<Node>>(`/nodes/${id}`);
  return response.data.data;
}

/**
 * Update node
 * PUT /nodes/:id
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 */
export async function updateNode(
  id: string,
  data: UpdateNodeRequest
): Promise<Node> {
  const response = await apiClient.put<APIResponse<Node>>(`/nodes/${id}`, data);
  return response.data.data;
}

/**
 * Delete node
 * DELETE /nodes/:id
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 */
export async function deleteNode(id: string): Promise<void> {
  await apiClient.delete(`/nodes/${id}`);
}

/**
 * List nodes with pagination and filters
 * GET /nodes
 * @requires Admin role
 * Updated: 2025-12-29 - Added sortBy and sortOrder params for sorting
 */
export async function listNodes(
  params?: ListNodesParams
): Promise<ListResponse<Node>> {
  const response = await apiClient.get<APIResponse<ListResponse<Node>>>(
    '/nodes',
    { params }
  );
  return response.data.data;
}

/**
 * Update node status (active/inactive/maintenance)
 * PATCH /nodes/:id/status
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 */
export async function updateNodeStatus(
  id: string,
  data: UpdateNodeStatusRequest
): Promise<Node> {
  const response = await apiClient.patch<APIResponse<Node>>(
    `/nodes/${id}/status`,
    data
  );
  return response.data.data;
}

/**
 * Generate API token for node
 * POST /nodes/:id/tokens
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 * @returns Token information (token is only shown once)
 */
export async function generateNodeToken(
  id: string
): Promise<GenerateNodeTokenResponse> {
  const response = await apiClient.post<APIResponse<GenerateNodeTokenResponse>>(
    `/nodes/${id}/tokens`
  );
  return response.data.data;
}

/**
 * Get install script command for node
 * GET /nodes/:id/install-script
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 * @returns Install script information including install/uninstall commands
 */
export async function getNodeInstallScript(
  id: string,
  params?: GetNodeInstallScriptParams
): Promise<GenerateNodeInstallScriptResponse> {
  const response = await apiClient.get<APIResponse<GenerateNodeInstallScriptResponse>>(
    `/nodes/${id}/install-script`,
    { params }
  );
  return response.data.data;
}

/**
 * Get node version information
 * GET /nodes/:id/version
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 * @returns Version info including current version, latest version, and update availability
 * Added: 2025-12-31
 */
export async function getNodeVersion(id: string): Promise<NodeVersionInfo> {
  const response = await apiClient.get<APIResponse<NodeVersionInfo>>(
    `/nodes/${id}/version`
  );
  return response.data.data;
}

/**
 * Trigger node agent update
 * POST /nodes/:id/update
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Admin role
 * @returns Update command info with command ID for tracking
 * Added: 2025-12-31
 */
export async function triggerNodeUpdate(id: string): Promise<TriggerNodeUpdateResponse> {
  const response = await apiClient.post<APIResponse<TriggerNodeUpdateResponse>>(
    `/nodes/${id}/update`
  );
  return response.data.data;
}

/**
 * Batch trigger node agent updates
 * POST /nodes/batch-update
 * @param data - Specify nodeIds for specific nodes, or set updateAll to true
 * @requires Admin role
 * @returns Batch update result with succeeded, failed, and skipped nodes
 * Added: 2025-12-31
 */
export async function batchTriggerNodeUpdate(
  data: BatchUpdateRequest
): Promise<BatchUpdateResponse> {
  const response = await apiClient.post<APIResponse<BatchUpdateResponse>>(
    '/nodes/batch-update',
    data
  );
  return response.data.data;
}

// ============================================================================
// User Node Management APIs
// Added: 2025-12-20
// ============================================================================

/**
 * Create a new user-owned node
 * POST /user/nodes
 * @requires Authentication
 * Added: 2025-12-20
 */
export async function createUserNode(
  data: CreateUserNodeRequest
): Promise<CreateUserNodeResponse> {
  const response = await apiClient.post<APIResponse<CreateUserNodeResponse>>(
    '/user/nodes',
    data
  );
  return response.data.data;
}

/**
 * List current user's nodes with pagination and filters
 * GET /user/nodes
 * @requires Authentication
 * Added: 2025-12-20
 */
export async function listUserNodes(
  params?: ListUserNodesParams
): Promise<ListResponse<UserNode>> {
  const response = await apiClient.get<APIResponse<ListResponse<UserNode>>>(
    '/user/nodes',
    { params }
  );
  return response.data.data;
}

/**
 * Get a specific user-owned node by ID
 * GET /user/nodes/:id
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Authentication, Ownership
 * Added: 2025-12-20
 */
export async function getUserNode(id: string): Promise<UserNode> {
  const response = await apiClient.get<APIResponse<UserNode>>(
    `/user/nodes/${id}`
  );
  return response.data.data;
}

/**
 * Update a user-owned node
 * PUT /user/nodes/:id
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Authentication, Ownership
 * Added: 2025-12-20
 */
export async function updateUserNode(
  id: string,
  data: UpdateUserNodeRequest
): Promise<UserNode> {
  const response = await apiClient.put<APIResponse<UserNode>>(
    `/user/nodes/${id}`,
    data
  );
  return response.data.data;
}

/**
 * Delete a user-owned node
 * DELETE /user/nodes/:id
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Authentication, Ownership
 * Added: 2025-12-20
 */
export async function deleteUserNode(id: string): Promise<void> {
  await apiClient.delete(`/user/nodes/${id}`);
}

/**
 * Regenerate token for a user-owned node
 * POST /user/nodes/:id/regenerate-token
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Authentication, Ownership
 * @returns New token (only shown once)
 * Added: 2025-12-20
 */
export async function regenerateUserNodeToken(
  id: string
): Promise<RegenerateUserNodeTokenResponse> {
  const response = await apiClient.post<APIResponse<RegenerateUserNodeTokenResponse>>(
    `/user/nodes/${id}/regenerate-token`
  );
  return response.data.data;
}

/**
 * Get current user's node usage and quota
 * GET /user/nodes/usage
 * @requires Authentication
 * @returns Node usage statistics and quota limits
 * Added: 2025-12-20
 */
export async function getUserNodeUsage(): Promise<UserNodeUsage> {
  const response = await apiClient.get<APIResponse<UserNodeUsage>>(
    '/user/nodes/usage'
  );
  return response.data.data;
}

/**
 * Get install script command for a user-owned node
 * GET /user/nodes/:id/install-script
 * @param id - Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
 * @requires Authentication, Ownership
 * @returns Install script information including install/uninstall commands
 * Added: 2025-12-20
 */
export async function getUserNodeInstallScript(
  id: string,
  params?: GetUserNodeInstallScriptParams
): Promise<UserNodeInstallScriptResponse> {
  const response = await apiClient.get<APIResponse<UserNodeInstallScriptResponse>>(
    `/user/nodes/${id}/install-script`,
    { params }
  );
  return response.data.data;
}

// ============================================================================
// Node SSE (Server-Sent Events) APIs
// Added: 2026-01-02
// ============================================================================

/**
 * Build absolute URL for SSE endpoint
 * Handles both absolute and relative baseURL configurations
 */
function buildSSEUrl(path: string, params?: Record<string, string>): string {
  const baseUrl = apiClient.defaults.baseURL || '';

  // Build the full path
  let fullUrl: string;
  if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
    // Absolute URL
    fullUrl = `${baseUrl}${path}`;
  } else {
    // Relative URL - use current origin
    const origin = typeof window !== 'undefined' ? window.location.origin : '';
    fullUrl = `${origin}${baseUrl}${path}`;
  }

  // Add query params
  if (params && Object.keys(params).length > 0) {
    const searchParams = new URLSearchParams(params);
    fullUrl += `?${searchParams.toString()}`;
  }

  return fullUrl;
}

/**
 * SSE connection options
 */
export interface NodeEventsOptions {
  /** Callback when connection is established */
  onOpen?: () => void;
  /** Callback for each received event */
  onEvent: (event: NodeEvent) => void;
  /** Callback on error (connection will be closed on repeated errors) */
  onError?: (error: Event) => void;
  /** Callback when connection is closed */
  onClose?: () => void;
  /** Max consecutive errors before closing connection (default: 3) */
  maxRetries?: number;
}

/**
 * Subscribe to real-time node events via SSE
 * GET /nodes/events
 * @param params - Optional filter params (nodeIds: comma-separated node IDs)
 * @param options - Event handlers and configuration
 * @requires Admin role (authentication via cookies)
 * @returns Cleanup function to close the SSE connection
 * Added: 2026-01-02
 *
 * Note: SSE uses cookie-based authentication. Ensure the user is logged in
 * and cookies are properly set before calling this function.
 *
 * The connection will automatically close after maxRetries consecutive errors
 * (e.g., authentication failures) to prevent infinite reconnection loops.
 *
 * @example
 * ```ts
 * const cleanup = subscribeNodeEvents(
 *   { nodeIds: 'node_abc,node_xyz' },
 *   {
 *     onOpen: () => console.log('Connected'),
 *     onEvent: (event) => {
 *       switch (event.type) {
 *         case 'node:online':
 *           console.log(`Node ${event.agentName} is online`);
 *           break;
 *         case 'node:offline':
 *           console.log(`Node ${event.agentName} is offline`);
 *           break;
 *         case 'node:status':
 *           console.log(`Node ${event.agentId} status:`, event.data);
 *           break;
 *       }
 *     },
 *     onError: (error) => console.error('SSE error:', error),
 *     onClose: () => console.log('Disconnected'),
 *   }
 * );
 *
 * // Later, to close the connection:
 * cleanup();
 * ```
 */
export function subscribeNodeEvents(
  params: NodeEventsParams | undefined,
  options: NodeEventsOptions
): () => void {
  const { onOpen, onEvent, onError, onClose, maxRetries = 3 } = options;

  // Build URL with query params
  const queryParams: Record<string, string> = {};
  if (params?.nodeIds) {
    queryParams['node_ids'] = params.nodeIds;
  }

  const url = buildSSEUrl('/nodes/events', queryParams);

  const eventSource = new EventSource(url, {
    withCredentials: true, // Send cookies for authentication
  });

  let errorCount = 0;
  let isClosed = false;

  // Handle connection open
  eventSource.onopen = () => {
    errorCount = 0; // Reset error count on successful connection
    if (onOpen) {
      onOpen();
    }
  };

  // Handle specific event types
  const eventTypes = ['node:online', 'node:offline', 'node:status', 'node:updated', 'nodes:status'];
  eventTypes.forEach((eventType) => {
    eventSource.addEventListener(eventType, (e: MessageEvent) => {
      errorCount = 0; // Reset error count on successful message
      try {
        const event = JSON.parse(e.data) as NodeEvent;
        onEvent(event);
      } catch (err) {
        console.error('Failed to parse SSE event:', err);
      }
    });
  });

  // Handle errors with retry limit to prevent infinite reconnection
  eventSource.onerror = (error) => {
    errorCount++;

    if (onError) {
      onError(error);
    }

    // Close connection after max retries to prevent infinite reconnection
    // (e.g., when session expires or user is unauthorized)
    if (errorCount >= maxRetries && !isClosed) {
      console.warn(
        `SSE connection closed after ${maxRetries} consecutive errors. ` +
        'This may indicate an authentication issue.'
      );
      eventSource.close();
      isClosed = true;
      if (onClose) {
        onClose();
      }
    }
  };

  // Return cleanup function
  return () => {
    if (!isClosed) {
      eventSource.close();
      isClosed = true;
      if (onClose) {
        onClose();
      }
    }
  };
}
